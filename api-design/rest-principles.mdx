---
title: "REST 원칙"
description: "RESTful API 설계의 핵심 원칙들을 알아봅니다."
icon: "network-wired"
---

# REST 원칙

REST(Representational State Transfer)는 웹 API 설계를 위한 아키텍처 스타일입니다.

## 핵심 원칙

### 1. 리소스 중심 설계

URL은 리소스(명사)를 나타내며, HTTP 메서드가 행위(동사)를 표현합니다:

```text
GET    /articles      - 목록 조회
GET    /articles/1    - 단일 조회
POST   /articles      - 생성
PUT    /articles/1    - 전체 수정
PATCH  /articles/1    - 부분 수정
DELETE /articles/1    - 삭제
```

### 2. HTTP 메서드의 올바른 사용

| 메서드 | 용도      | 멱등성 | 안전성 |
| ------ | --------- | ------ | ------ |
| GET    | 조회      | ✅     | ✅     |
| POST   | 생성      | ❌     | ❌     |
| PUT    | 전체 수정 | ✅     | ❌     |
| PATCH  | 부분 수정 | ❌     | ❌     |
| DELETE | 삭제      | ✅     | ❌     |

<Info>
  **멱등성**: 같은 요청을 여러 번 해도 결과가 동일함 **안전성**: 서버 상태를
  변경하지 않음
</Info>

### 3. 상태 코드 사용

```text
200 OK - 성공
201 Created - 생성 성공
204 No Content - 성공 (응답 본문 없음)
400 Bad Request - 잘못된 요청
401 Unauthorized - 인증 필요
403 Forbidden - 권한 없음
404 Not Found - 리소스 없음
500 Internal Server Error - 서버 오류
```

<Accordion title="상태 코드 카테고리">
  | 범위 | 카테고리 | 설명 | |------|----------|------| | 1xx | 정보 | 요청을
  받았으며 처리 중 | | 2xx | 성공 | 요청이 성공적으로 처리됨 | | 3xx |
  리다이렉션 | 추가 작업 필요 | | 4xx | 클라이언트 오류 | 요청에 오류가 있음 | |
  5xx | 서버 오류 | 서버에서 처리 실패 |
</Accordion>

### 4. 무상태(Stateless)

각 요청은 독립적이며, 서버는 클라이언트 상태를 저장하지 않습니다:

```typescript
// 모든 필요한 정보는 요청에 포함
fetch("/api/orders", {
  headers: {
    Authorization: "Bearer <token>",
    "Content-Type": "application/json",
  },
});
```

<Warning>
  세션을 서버에 저장하지 마세요. JWT 같은 토큰 기반 인증을 사용하세요.
</Warning>

## 리소스 관계

### 중첩 리소스

```text
GET /users/123/posts        - 사용자의 게시글 목록
GET /users/123/posts/456    - 특정 게시글
```

### 쿼리 파라미터

```text
GET /posts?author=123           - 필터링
GET /posts?sort=created_at      - 정렬
GET /posts?page=2&limit=10      - 페이지네이션
GET /posts?fields=id,title      - 필드 선택
```

<Tip>
  중첩이 3단계를 넘어가면 너무 복잡해집니다. 대신 쿼리 파라미터로 필터링하세요.
</Tip>

## 응답 설계

### 성공 응답

```json
{
  "data": {
    "id": 1,
    "title": "Hello World",
    "author": {
      "id": 123,
      "name": "John"
    }
  },
  "meta": {
    "timestamp": "2024-12-28T00:00:00Z"
  }
}
```

### 목록 응답

```json
{
  "data": [...],
  "pagination": {
    "page": 1,
    "limit": 10,
    "total": 100,
    "totalPages": 10
  }
}
```

### 에러 응답

```json
{
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "The request body is invalid",
    "details": [
      {
        "field": "email",
        "message": "Invalid email format"
      }
    ]
  }
}
```

<Note>일관된 응답 형식을 유지하면 클라이언트에서 처리하기 쉬워집니다.</Note>

## REST 설계 체크리스트

<Steps>
  <Step title="리소스 명명">복수형 명사 사용 (`/users`, `/posts`)</Step>
  <Step title="HTTP 메서드">
    적절한 메서드 사용 (GET, POST, PUT, PATCH, DELETE)
  </Step>
  <Step title="상태 코드">의미 있는 HTTP 상태 코드 반환</Step>
  <Step title="버저닝">API 버전 관리 전략 적용</Step>
  <Step title="문서화">OpenAPI/Swagger로 문서화</Step>
</Steps>

## 베스트 프랙티스 요약

<CardGroup cols={2}>
  <Card title="DO" icon="check">
    - 리소스에 복수형 명사 사용 - 적절한 HTTP 상태 코드 반환 - 일관된 응답 형식
    유지 - API 버전 관리
  </Card>
  <Card title="DON'T" icon="xmark">
    - URL에 동사 사용 (getUsers) - 모든 응답에 200 반환 - 세션 기반 상태 저장 -
    버저닝 없이 변경
  </Card>
</CardGroup>

